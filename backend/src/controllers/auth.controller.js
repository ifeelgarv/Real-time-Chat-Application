import { upsertStreamUser } from "../lib/stream.js";
import User from "../models/User.js";
import jwt from "jsonwebtoken";

export async function signup(req, res) {
  // Retrieves data from the frontend form (POST request)
  const { email, password, fullName } = req.body;

  try {
    // Basic Input Validation
    if (!email || !password || !fullName) {
      return res.status(400).json({ message: "All fields are required" });
    }

    // Password length validation
    if (password.length < 6) {
      return res
        .status(400)
        .json({ message: "Password must be at least 6 characters" });
    }

    // Email format validation
    const emailRegex = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ message: "Email is not valid" });
    }

    // Check for existing user
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: "Email already exists" });
    }

    // Generate random avatar - Sets a random avatar for the user
    const idx = Math.floor(Math.random() * 100) + 1;
    const randomAvatar = `https://avatar.iran.liara.run/public/${idx}.png`;

    // Create new user - Creates a new user in the database The password is hashed automatically by the Mongoose.
    // This uses the Mongoose model User to insert a new document (a new row) into the MongoDB users collection.
    // You wait for MongoDB to save the data (because .create() is an async function).
    // const newUser = After the user is saved, newUser contains the full MongoDB document — including the autogenerated _id, timestamps, etc.
    const newUser = await User.create({
      email,
      password,
      fullName,
      profilePicture: randomAvatar,
    });

    // Todo: Create the user in stream as well
    try {
        await upsertStreamUser({
            id: newUser._id.toString(),
            name: newUser.fullName,
            image: newUser.profilePicture || "",
        });
        console.log(`Stream user created for ${newUser.fullName}`);
    } catch (error) {
        console.error("Error creating Stream user:", error);
    }

    // Generate JWT token - Creates a JWT token for the user. [{ userId: newUser._id } This is the payload — the data you're storing inside the token.newUser._id is the unique ID that MongoDB gives to the user. You're storing this so you can identify the user later when they send the token back.]. You're creating a new user in the database. The response is stored in the variable newUser. So you access their ID like this: newUser._id.
    const token = jwt.sign(
      { userId: newUser._id },
      process.env.JWT_SECRET_KEY,
      {
        expiresIn: "7d",
      }
    );

    /* What this does:
        This code tells the browser to store a cookie named "token" with the JWT token inside. That cookie will automatically be sent back with future requests (like when visiting a protected page).
        It's like saying:  “Hey browser, here’s a cookie. Its name is cookie, it contains a JWT, keep it for 7 days, don’t let JS touch it, and only send it back to me on safe, same-site, secure connections.”
    */

    // "token"	The name of the cookie you're setting.
    // token	The value (JWT) that you're storing inside the cookie.
    res.cookie("token", token, {
      maxAge: 7 * 24 * 60 * 60 * 1000, // maxAge: 7 * 24 * 60 * 60 * 1000	The cookie will last for 7 days.
      httpOnly: true, // httpOnly: true	JavaScript can't access the cookie (helps protect against XSS attacks).
      sameSite: "strict", // sameSite: "strict"	Cookie only sent for same-site requests (helps protect against CSRF).
      secure: process.env.NODE_ENV === "production", // secure: process.env.NODE_ENV === "production"	Cookie sent only over HTTPS in production mode (extra security).
    });

    res.status(201).json({ success: true, user: newUser }); // Sends back the newly created user. It sends a JSON response back to the client (like the frontend), saying: ✅ Signup was successful! Here's the user we just created. user: newUser sends the details of the newly created user (from MongoDB).
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Internal server error" });
  }
}

export async function login(req, res) {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ message: "All fields are required" });
    }

    const user = await User.findOne({
      email,
    });
    if (!user) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    const isPasswordValid = await user.matchPassword(password);
    if (!isPasswordValid) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    const token = jwt.sign(
      { userId: user._id }, // You're finding an existing user based on their email. The response is stored in the variable user. So you access their ID like this: user._id.
      process.env.JWT_SECRET_KEY,
      {
        expiresIn: "7d",
      }
    );

    res.cookie("token", token, {
      maxAge: 7 * 24 * 60 * 60 * 1000, // maxAge: 7 * 24 * 60 * 60 * 1000	The cookie will last for 7 days.
      httpOnly: true, // httpOnly: true	JavaScript can't access the cookie (helps protect against XSS attacks).
      sameSite: "strict", // sameSite: "strict"	Cookie only sent for same-site requests (helps protect against CSRF).
      secure: process.env.NODE_ENV === "production", // secure: process.env.NODE_ENV === "production"	Cookie sent only over HTTPS in production mode (extra security).
    });

    res.status(200).json({success: true, user});
  } catch (error) {
    console.log("Error in login controller", error.message);
    res.status(500).json({ message: "Internal Server Error" });
  }
}

export async function logout(req, res) {
  res.clearCookie("token");
  res.status(200).json({ success:true, message: "Logged out successfully" });
}


export async function onboard(req, res) {
    try {
      const userId = req.user._id; // Get the user ID from the request object
      const {fullName, bio, nativeLanguage, learningLanguage, location} = req.body;

      if(!fullName || !bio || !nativeLanguage || !learningLanguage || !location) {
        return res.status(400).json({ message: "All fields are required",
          missingFields: [
            !fullName ? "fullName" : null,
            !bio ? "bio" : null,
            !nativeLanguage ? "nativeLanguage" : null,
            !learningLanguage ? "learningLanguage" : null,
            !location ? "location" : null,
          ].filter(Boolean) // Filters out any null values
        });
      }

      const updatedUser = await User.findByIdAndUpdate(userId, {
        ...req.body,
        isOnboarded: true,
      }, { new: true});

      try {
        await upsertStreamUser({
          id: updatedUser._id.toString(),
          name: updatedUser.fullName,
          image: updatedUser.profilePicture || "",
        })
        console.log(`Stream user updated after onboarding for ${updatedUser.fullName}`);
      } catch (streamError) {
        console.log("Error updating Stream user during onboarding:", streamError.message)
      }
      
      if (!updatedUser) return res.status(404).json({ message: "User not found"});

      res.status(200).json({success: true, user: updatedUser});
    } catch (error) {
      console.error("Onboard error:", error);
      res.status(500).json({ message: "Internal server error" });
    }
}