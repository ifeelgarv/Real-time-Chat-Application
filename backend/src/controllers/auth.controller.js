import { upsertStreamUser } from "../lib/stream.js";
import User from "../models/User.js";
import jwt from "jsonwebtoken";

export async function signup(req, res) {
  // Retrieves data from the frontend form (POST request)
  const { email, password, fullName } = req.body;

  try {
    // Basic Input Validation
    if (!email || !password || !fullName) {
      return res.status(400).json({ message: "All fields are required" });
    }

    // Password length validation
    if (password.length < 6) {
      return res
        .status(400)
        .json({ message: "Password must be at least 6 characters" });
    }

    // Email format validation
    const emailRegex = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ message: "Email is not valid" });
    }

    // Check for existing user
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: "Email already exists" });
    }

    // Generate random avatar - Sets a random avatar for the user
    const idx = Math.floor(Math.random() * 100) + 1;
    const randomAvatar = `https://avatar.iran.liara.run/public/${idx}.png`;

    // Create new user - Creates a new user in the database The password is hashed automatically by the Mongoose.
    // This uses the Mongoose model User to insert a new document (a new row) into the MongoDB users collection.
    // You wait for MongoDB to save the data (because .create() is an async function).
    // const newUser = After the user is saved, newUser contains the full MongoDB document — including the autogenerated _id, timestamps, etc.
    const newUser = await User.create({
      email,
      password,
      fullName,
      profilePicture: randomAvatar,
    });

    // Todo: Create the user in stream as well
    try {
      await upsertStreamUser({
        id: newUser._id.toString(),
        name: newUser.fullName,
        image: newUser.profilePicture || "",
      });
      console.log(`Stream user created for ${newUser.fullName}`);
    } catch (error) {
      console.error("Error creating Stream user:", error);
    }

    // Generate JWT token - Creates a JWT token for the user. [{ userId: newUser._id } This is the payload — the data you're storing inside the token.newUser._id is the unique ID that MongoDB gives to the user. You're storing this so you can identify the user later when they send the token back.]. You're creating a new user in the database. The response is stored in the variable newUser. So you access their ID like this: newUser._id.
    const token = jwt.sign(
      { userId: newUser._id },
      process.env.JWT_SECRET_KEY,
      {
        expiresIn: "7d",
      }
    );

    /* What this does:
        This code tells the browser to store a cookie named "token" with the JWT token inside. That cookie will automatically be sent back with future requests (like when visiting a protected page).
        It's like saying:  “Hey browser, here’s a cookie. Its name is cookie, it contains a JWT, keep it for 7 days, don’t let JS touch it, and only send it back to me on safe, same-site, secure connections.”
    */

    // "token"	The name of the cookie you're setting.
    // token	The value (JWT) that you're storing inside the cookie.
    res.cookie("token", token, {
      maxAge: 7 * 24 * 60 * 60 * 1000, // maxAge: 7 * 24 * 60 * 60 * 1000	The cookie will last for 7 days.
      httpOnly: true, // httpOnly: true	JavaScript can't access the cookie (helps protect against XSS attacks).
      sameSite: "strict", // sameSite: "strict"	Cookie only sent for same-site requests (helps protect against CSRF).
      secure: process.env.NODE_ENV === "production", // secure: process.env.NODE_ENV === "production"	Cookie sent only over HTTPS in production mode (extra security).
    });

    res.status(201).json({ success: true, user: newUser }); // Sends back the newly created user. It sends a JSON response back to the client (like the frontend), saying: ✅ Signup was successful! Here's the user we just created. user: newUser sends the details of the newly created user (from MongoDB).
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Internal server error" });
  }
}

export async function login(req, res) {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ message: "All fields are required" });
    }

    const user = await User.findOne({
      email,
    });
    if (!user) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    const isPasswordValid = await user.matchPassword(password);
    if (!isPasswordValid) {
      return res.status(401).json({ message: "Invalid credentials" });
    }

    const token = jwt.sign(
      { userId: user._id }, // You're finding an existing user based on their email. The response is stored in the variable user. So you access their ID like this: user._id.
      process.env.JWT_SECRET_KEY,
      {
        expiresIn: "7d",
      }
    );

    res.cookie("token", token, {
      maxAge: 7 * 24 * 60 * 60 * 1000, // maxAge: 7 * 24 * 60 * 60 * 1000	The cookie will last for 7 days.
      httpOnly: true, // httpOnly: true	JavaScript can't access the cookie (helps protect against XSS attacks).
      sameSite: "strict", // sameSite: "strict"	Cookie only sent for same-site requests (helps protect against CSRF).
      secure: process.env.NODE_ENV === "production", // secure: process.env.NODE_ENV === "production"	Cookie sent only over HTTPS in production mode (extra security).
    });

    res.status(200).json({ success: true, user });
  } catch (error) {
    console.log("Error in login controller", error.message);
    res.status(500).json({ message: "Internal Server Error" });
  }
}

export async function logout(req, res) {
  res.clearCookie("token");
  res.status(200).json({ success: true, message: "Logged out successfully" });
}

// This function handles onboarding a user by saving their profile details like name, bio, languages, and location
export async function onboard(req, res) {
  try {
    // Get the logged-in user's ID from the request object (set in middleware)
    const userId = req.user._id;

    // Destructure the required fields from the request body (sent from frontend)
    const { fullName, bio, nativeLanguage, learningLanguage, location } =
      req.body;

    // Check if any of the required fields are missing
    if (
      !fullName ||
      !bio ||
      !nativeLanguage ||
      !learningLanguage ||
      !location
    ) {
      // If any field is missing, return 400 Bad Request with the names of missing fields
      return res.status(400).json({
        message: "All fields are required",
        missingFields: [
          !fullName ? "fullName" : null, // Add "fullName" to list if it's missing
          !bio ? "bio" : null, // Same for "bio"
          !nativeLanguage ? "nativeLanguage" : null,
          !learningLanguage ? "learningLanguage" : null,
          !location ? "location" : null,
        ].filter(Boolean), // Remove any null values from the array
      });
    }

    // If all required fields are present, update the user in the database with the new info
    const updatedUser = await User.findByIdAndUpdate(
      userId, // Find the user by ID
      {
        ...req.body, // Spread all fields from the request body
        isOnboarded: true, // Mark user as onboarded
      },
      { new: true } // Return the updated user document
    );

    // Try to update the user in the Stream API (for chat or social features)
    try {
      await upsertStreamUser({
        id: updatedUser._id.toString(), // Convert ObjectId to string
        name: updatedUser.fullName, // Use the updated full name
        image: updatedUser.profilePicture || "", // Use profile picture if available
      });

      // Log success message to the console
      console.log(
        `Stream user updated after onboarding for ${updatedUser.fullName}`
      );
    } catch (streamError) {
      // Catch any error from updating Stream and log it
      console.log(
        "Error updating Stream user during onboarding:",
        streamError.message
      );
    }

    // If user was not found and update failed, send a 404 Not Found response
    if (!updatedUser)
      return res.status(404).json({ message: "User not found" });

    // If everything is successful, return the updated user
    res.status(200).json({ success: true, user: updatedUser });
  } catch (error) {
    // Catch any unexpected server error and log it
    console.error("Onboard error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
}
